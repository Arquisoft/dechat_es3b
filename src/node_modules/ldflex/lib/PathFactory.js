"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.toHandler = toHandler;
exports.toResolver = toResolver;
exports.default = exports.defaultHandlers = void 0;

var _PathProxy = _interopRequireDefault(require("./PathProxy"));

var _PathExpressionHandler = _interopRequireDefault(require("./PathExpressionHandler"));

var _ExecuteQueryHandler = _interopRequireDefault(require("./ExecuteQueryHandler"));

var _SparqlHandler = _interopRequireDefault(require("./SparqlHandler"));

var _JSONLDResolver = _interopRequireDefault(require("./JSONLDResolver"));

var _FallbackHandler = _interopRequireDefault(require("./FallbackHandler"));

var _StringToLDflexHandler = _interopRequireDefault(require("./StringToLDflexHandler"));

var _SubjectHandler = _interopRequireDefault(require("./SubjectHandler"));

var _iterableUtils = require("./iterableUtils");

// Default iterator behavior:
// - first try returning the subject (single-segment path)
// - then execute a path query (multi-segment path)
const iteratorHandler = new _FallbackHandler.default([(0, _iterableUtils.promiseToIterable)(new _SubjectHandler.default()), new _ExecuteQueryHandler.default()]);
/**
 * Collection of default property handlers.
 */

const defaultHandlers = {
  // Flag to loaders that exported paths are not ES6 modules
  __esModule: () => undefined,
  // Add iterable and thenable behavior
  [Symbol.asyncIterator]: (0, _iterableUtils.getIterator)(iteratorHandler),
  then: (0, _iterableUtils.iterableToThen)(iteratorHandler),
  // Add path handling
  pathExpression: new _PathExpressionHandler.default(),
  sparql: new _SparqlHandler.default(),
  // Parse a string into an LDflex object
  resolve: new _StringToLDflexHandler.default()
};
/**
 * A PathFactory creates paths with default settings.
 */

exports.defaultHandlers = defaultHandlers;

class PathFactory {
  constructor(settings, data) {
    // Store settings and data
    settings = Object.assign(Object.create(null), settings);
    this._settings = settings;
    this._data = data; // Prepare the handlers

    const handlers = settings.handlers || PathFactory.defaultHandlers;

    for (var key in handlers) handlers[key] = toHandler(handlers[key]); // Prepare the resolvers


    const resolvers = (settings.resolvers || []).map(toResolver);
    if (settings.context) resolvers.push(new _JSONLDResolver.default(settings.context)); // Instantiate PathProxy that will create the paths

    this._pathProxy = new _PathProxy.default({
      handlers,
      resolvers
    }); // Remove PathProxy settings from the settings object

    delete settings.handlers;
    delete settings.resolvers;
    delete settings.context;
  }
  /**
   * Creates a path with the given (optional) settings and data.
   */


  create(settings = {}, data) {
    // The settings parameter is optional
    if (!data) [data, settings] = [settings, null]; // Apply defaults on settings and data

    return this._pathProxy.createPath(Object.assign(Object.create(null), this._settings, settings), Object.assign(Object.create(null), this._data, data));
  }

}

exports.default = PathFactory;
PathFactory.defaultHandlers = defaultHandlers;
/**
 * Converts a handler function into a handler object.
 */

function toHandler(execute) {
  return typeof execute.execute === 'function' ? execute : {
    execute
  };
}
/**
 * Converts a resolver function into a catch-all resolver object.
 */


function toResolver(resolve) {
  return typeof resolve.resolve === 'function' ? resolve : {
    supports,
    resolve
  };
} // Catch-all resolvers support everything


function supports() {
  return true;
}